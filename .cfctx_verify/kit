#!/usr/bin/env bash
set -euo pipefail

# ============================================================
# kit — Verification Kit unified CLI
# Usage: ./kit <subcommand> [args]
#
# Subcommands:
#   handoff          Regenerate handoff/latest.md
#   verify [GATE]    Run gate verification (auto-discovered, or all)
#   test [PHASE]     Run tests (1/2/3/all, default: all)
#   ciqa [CHECK...]  CI/QA checks (tracker/evidence/ssot/all)
#   all              verify + test + ciqa + handoff (full pipeline)
#   status           Show tracker progress summary
#   lockdown         Move kit to quarantine (Phase 5)
#   unlock           Restore kit from quarantine (Phase 5)
# ============================================================

# ── Resolve KIT_ROOT ─────────────────────────────────────────
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
KIT_ROOT="$SCRIPT_DIR"
export KIT_ROOT

# ── Source libraries ─────────────────────────────────────────
source "${KIT_ROOT}/scripts/lib/handoff_builder.sh"
source "${KIT_ROOT}/scripts/lib/tracker_updater.sh"
source "${KIT_ROOT}/scripts/lib/gate_registry.sh"

# ── Tracker auto-update helpers ────────────────────────────────
# Parse verify output for GATE_EVIDENCE markers and gate verdicts,
# then call update_verify_tracker + append_progress_log.
_kit_update_verify_from_output() {
  local output="$1"
  local verify_tracker="${KIT_ROOT}/tasks/verify_task_tracker.md"
  local marker gate evidence_rel verdict

  while IFS=: read -r marker gate evidence_rel; do
    [[ "$marker" == "GATE_EVIDENCE" ]] || continue
    verdict="$(echo "$output" | grep "  Gate ${gate}: " | grep -oE '(PASS|FAIL)' | tail -1)" || verdict=""
    if [[ -n "$verdict" && -n "$evidence_rel" ]]; then
      update_verify_tracker "$gate" "$verdict" "$evidence_rel" || true
    fi
  done < <(echo "$output" | grep '^GATE_EVIDENCE:' || true)

  local summary
  summary="$(echo "$output" | grep '^Total:' | head -1)" || summary=""
  if [[ -n "$summary" ]]; then
    append_progress_log "$verify_tracker" "kit verify: ${summary}" || true
  fi
}

# Parse test output for Phase verdicts and evidence paths,
# then call update_test_tracker + append_progress_log.
_kit_update_test_from_output() {
  local output="$1"
  local test_tracker="${KIT_ROOT}/tasks/test_task_tracker.md"
  local line p_num p_verdict p_evidence

  while IFS= read -r line; do
    if [[ "$line" =~ Phase\ ([0-9]+):\ (PASS|FAIL)\ +Evidence:\ ([^ ]+) ]]; then
      p_num="${BASH_REMATCH[1]}"
      p_verdict="${BASH_REMATCH[2]}"
      p_evidence="${BASH_REMATCH[3]}"
      update_test_tracker "$p_num" "$p_verdict" "$p_evidence" || true
    fi
  done <<< "$output"

  local summary
  summary="$(echo "$output" | grep '^Total:.*phases' | tail -1)" || summary=""
  if [[ -n "$summary" ]]; then
    append_progress_log "$test_tracker" "kit test: ${summary}" || true
  fi
}

# ── Usage ────────────────────────────────────────────────────
kit_usage() {
  local gates_str
  gates_str="$(gr_list_gate_ids | tr '\n' ',' | sed 's/,$//')"

  cat <<EOF
Usage: ./kit <subcommand> [args]

Subcommands:
  handoff          Regenerate handoff/latest.md and latest.txt
  verify [GATE]    Run gate verification (individually or all gates)
  test [PHASE]     Run tests (1, 2, 3, all; default: all)
  ciqa [CHECK...]  CI/QA checks (tracker, evidence, ssot, or all)
  all              verify + test + ciqa + handoff (full pipeline)
  status           Show tracker progress summary
  lockdown         Move kit to quarantine (Phase 5)
  unlock           Restore kit from quarantine (Phase 5)

Available gates: ${gates_str}
  (auto-discovered from scripts/lib/gate_*.sh)

Examples:
  ./kit handoff        # Regenerate latest.md
  ./kit verify         # Run all gates
  ./kit verify C       # Run Gate C only
  ./kit verify A B C   # Run Gates A, B, C
  ./kit test           # Run all test phases
  ./kit test 2         # Run Phase 2 tests only
  ./kit ciqa           # Run all CI/QA checks
  ./kit ciqa tracker   # Run tracker integrity check only
  ./kit all            # Full pipeline
  ./kit status         # Show progress
  ./kit lockdown       # Move kit to quarantine
  ./kit unlock         # Restore from quarantine
EOF
}

# ── Subcommand: handoff ──────────────────────────────────────
kit_handoff() {
  echo "=== kit handoff ==="
  bash "${KIT_ROOT}/scripts/generate_handoff.sh"
}

# ── Subcommand: verify ───────────────────────────────────────
kit_verify() {
  echo "=== kit verify ==="

  local exit_code=0
  local _output

  if [[ $# -eq 0 ]]; then
    _output="$(bash "${KIT_ROOT}/scripts/verify_all.sh" 2>&1)" || exit_code=$?
  else
    _output="$(bash "${KIT_ROOT}/scripts/verify_gate.sh" "$@" 2>&1)" || exit_code=$?
  fi

  echo "$_output"

  # Auto-update tracker from verify output
  _kit_update_verify_from_output "$_output"

  # Regenerate handoff after verification
  echo ""
  echo "--- Regenerating handoff ---"
  bash "${KIT_ROOT}/scripts/generate_handoff.sh"

  return "$exit_code"
}

# ── Subcommand: test ─────────────────────────────────────────
kit_test() {
  echo "=== kit test ==="

  local phase="${1:-all}"
  local exit_code=0

  # Check if test runner exists
  local test_runner="${KIT_ROOT}/scripts/run_tests.sh"
  if [[ ! -f "$test_runner" ]]; then
    echo "WARN: No test runner found at ${test_runner}" >&2
    echo "Test execution is not yet implemented." >&2
    echo "Supported phases: 1, 2, 3, all" >&2
    return 1
  fi

  local _output
  _output="$(bash "$test_runner" "$phase" 2>&1)" || exit_code=$?

  echo "$_output"

  # Auto-update tracker from test output
  _kit_update_test_from_output "$_output"

  # Regenerate handoff after tests
  echo ""
  echo "--- Regenerating handoff ---"
  bash "${KIT_ROOT}/scripts/generate_handoff.sh"

  return "$exit_code"
}

# ── Subcommand: ciqa ────────────────────────────────────────
kit_ciqa() {
  local exit_code=0

  local ciqa_runner="${KIT_ROOT}/scripts/ciqa_runner.sh"
  if [[ ! -f "$ciqa_runner" ]]; then
    echo "ERROR: CIQA runner not found at ${ciqa_runner}" >&2
    return 1
  fi

  bash "$ciqa_runner" "$@" || exit_code=$?

  # Regenerate handoff after ciqa
  echo ""
  echo "--- Regenerating handoff ---"
  bash "${KIT_ROOT}/scripts/generate_handoff.sh"

  return "$exit_code"
}

# ── Subcommand: all ──────────────────────────────────────────
kit_all() {
  echo "=============================================="
  echo " kit all — Full Pipeline"
  echo "=============================================="
  echo ""

  local exit_code=0

  # Step 1: verify all gates
  echo ">>> Step 1/4: verify (all gates)"
  echo ""
  local _verify_output
  _verify_output="$(bash "${KIT_ROOT}/scripts/verify_all.sh" 2>&1)" || exit_code=$?
  echo "$_verify_output"
  _kit_update_verify_from_output "$_verify_output"
  echo ""

  # Step 2: test all phases
  echo ">>> Step 2/4: test (all phases)"
  echo ""
  local test_runner="${KIT_ROOT}/scripts/run_tests.sh"
  if [[ -f "$test_runner" ]]; then
    local _test_output
    _test_output="$(bash "$test_runner" all 2>&1)" || exit_code=$?
    echo "$_test_output"
    _kit_update_test_from_output "$_test_output"
  else
    echo "WARN: No test runner (${test_runner}), skipping tests."
  fi
  echo ""

  # Step 3: ciqa (CI/QA checks)
  echo ">>> Step 3/4: ciqa (CI/QA checks)"
  echo ""
  local ciqa_runner="${KIT_ROOT}/scripts/ciqa_runner.sh"
  if [[ -f "$ciqa_runner" ]]; then
    bash "$ciqa_runner" all || exit_code=$?
  else
    echo "WARN: No CIQA runner (${ciqa_runner}), skipping CI/QA."
  fi
  echo ""

  # Step 4: handoff (final regeneration)
  echo ">>> Step 4/4: handoff (final generation)"
  echo ""
  bash "${KIT_ROOT}/scripts/generate_handoff.sh"
  echo ""

  echo "=============================================="
  if [[ "$exit_code" -eq 0 ]]; then
    echo " kit all: ALL PASS"
  else
    echo " kit all: SOME FAILURES (exit code: ${exit_code})"
  fi
  echo "=============================================="

  return "$exit_code"
}

# ── Subcommand: status ───────────────────────────────────────
kit_status() {
  _hb_ensure_roots

  echo "=== Kit Status ==="
  echo ""

  local trackers=(
    "Verify:tasks/verify_task_tracker.md"
    "Test:tasks/test_task_tracker.md"
    "As-built:tasks/as_built_task_tracker.md"
    "Rebuild:tasks/rebuild_task_tracker.md"
    "PostRebld:tasks/post_rebuild_task_tracker.md"
    "CIQA:tasks/ciqa_task_tracker.md"
  )

  for entry in "${trackers[@]}"; do
    local label="${entry%%:*}"
    local fpath="${KIT_ROOT}/${entry#*:}"

    if [[ ! -f "$fpath" ]]; then
      printf "  %-10s N/A (file not found)\n" "${label}:"
      continue
    fi

    local done_count total_unchecked total pct status_label
    done_count="$(grep -cP '^\s*- \[x\]' "$fpath" 2>/dev/null)" || done_count=0
    total_unchecked="$(grep -cP '^\s*- \[ \]' "$fpath" 2>/dev/null)" || total_unchecked=0
    total=$((done_count + total_unchecked))

    if [[ "$total" -gt 0 ]]; then
      pct=$(( done_count * 100 / total ))
    else
      pct=0
    fi

    if [[ "$total_unchecked" -eq 0 && "$total" -gt 0 ]]; then
      local fail_count
      fail_count="$(grep -c '判定: FAIL' "$fpath" 2>/dev/null)" || fail_count=0
      if [[ "$fail_count" -gt 0 ]]; then
        status_label="HAS_FAIL"
      else
        status_label="ALL_PASS"
      fi
    elif [[ "$total" -eq 0 ]]; then
      status_label="EMPTY"
    else
      status_label="IN_PROGRESS"
    fi

    printf "  %-10s %2d/%-2d (%3d%%) %s\n" "${label}:" "$done_count" "$total" "$pct" "$status_label"
  done

  echo ""
  echo "Kit root: ${KIT_ROOT}"
  echo "Timestamp: $(TZ=Asia/Tokyo date '+%Y-%m-%d %H:%M JST')"
}

# ── Subcommand: lockdown ──────────────────────────────────────
kit_lockdown() {
  echo "=== kit lockdown ==="
  bash "${KIT_ROOT}/scripts/lockdown.sh" "$@"
}

# ── Subcommand: unlock ───────────────────────────────────────
kit_unlock() {
  echo "=== kit unlock ==="
  bash "${KIT_ROOT}/scripts/unlock.sh" "$@"
}

# ── Main dispatch ────────────────────────────────────────────
if [[ $# -lt 1 ]]; then
  kit_usage
  exit 1
fi

subcmd="$1"
shift

case "$subcmd" in
  handoff)  kit_handoff "$@" ;;
  verify)   kit_verify "$@" ;;
  test)     kit_test "$@" ;;
  ciqa)     kit_ciqa "$@" ;;
  all)      kit_all "$@" ;;
  status)   kit_status "$@" ;;
  lockdown) kit_lockdown "$@" ;;
  unlock)   kit_unlock "$@" ;;
  --help|-h|help)
            kit_usage ;;
  *)
    echo "ERROR: Unknown subcommand '$subcmd'" >&2
    echo "" >&2
    kit_usage >&2
    exit 1
    ;;
esac
